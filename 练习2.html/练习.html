<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
   //类的多态：重载和重写，Java中重载：函数名相同，但是传参类型，数量不同或者返回值不一样，这相当于把一个函数重载了（js中没有类似于后台语言中的重载机制。js中的重载只是同一个方法，根据传参不同，实现不同的业务逻辑）
   //重写：子类重写父类上的方法


  //继承：    子类继承父类中的属性和方法（js中的继承机制和其他后台语言是不一样的，有自己的独特处理方式）

  //方案一：原型继承（子类的原型指向父类的一个实例）
   //(1)并不会把父类中的方法克隆一份给子类，而是建立了子类和父类之前的原型链查找机制（2）重定向子类的原型后，默认丢失了原本的constructor属性（或者原本在原型上设置的属性和方法）（3）子类或者子类的实例，可以基于原型链”肆意“修改父类上的属性方法，对付类造成一些”不必要的破坏“（4）会把父类中私有的属性方法作为子类公有的属性方法继承过来（父类中不管是公有还是私有，最后都变为子类共有的）



    function A(){
        this.x = 100;
    }
    A.prototype.getx = function getx(){
        console.log(x)
    }

    function B(){
        this.y = 200;
    }
    B.prototype = new A;
    B.prototyoe.getb = function getb(){
        console.log(b)
    };
    let b = new B;

</script>

<script>
//call继承
//call继承：把父类当作普通函数执行，让其执行的时候，方法中的this变为子类的实例即可
// (1)只能继承父类中的私有属性（继承的私有属性赋予值给与子类实例的私有属性）而且类似拷贝过来一份，而不是链式查找
//（2）因为只是把父亲当作普通的方法执行，所以父亲原型上的公有属性方法无法被继承过来


function A(){
        this.x = 100;
    }
    A.prototype.getx = function getx(){
        console.log(x)
    }

    function B(){
        this.y = 200;
        //call继承
        A.call(this);//=this.x=100 ,b.x=100
    }
    B.prototype = new A;
    B.prototyoe.getb = function getb(){
        console.log(b)
    };
    let b = new B;
</script>
<script>
//寄生组合继承：call继承+变异版的原型继承共同完成的，call继承实现：私有到私有  原型继承实现：公有到公有

function A(){
        this.x = 100;
    }
    A.prototype.getx = function getx(){
        console.log(x)
    }

    function B(){
        this.y = 200;
        //call继承
        A.call(this);//=this.x=100 ,b.x=100
    }
    //=object.create(obj)创建一个空对象，让_proto_指向obj（把obj作为空对象的原型）
    B.prototype = Object.create(A.prototype);
    B.prototype.constrctor = B
    B.prototyoe.getb = function getb(){
        console.log(b)
    };
    let b = new B;

</script>
<script>
//Es6中创建类用class
class A{
  constructor(){
      this.x = 1000;
  }
  //=这样和构造函数中的this.xxx=xxx没什么区别，设置的是私有属性（es7）
  num = 100;
  //=设置到A.prototype上的方法
  getX(){
    console.log(this.x);
   }
   //=把A当作普通对象设置的属性和方法
   static n = 200;
   static getN(){}
}
console.log(newA)
//=extends继承和寄生组合继承基本类似
class A{
  constructor(){
      this.x = 100
  }
  getX(){
      console,log(this.x);
  }
}


class B extends A{
  constructor(){
      super() //=一旦使用extends实现继承，只要自己写了construtor，就必须写super《=》A.call(this)
      this.b = 200
  }
  getY(){
      console,log(this.y);
  }


}
//=真是项目中使用继承的地方
// 1.react创建类的组件  2.自己写插件或者类库的时候
</script>
<script>
//=（浏览器底层渲染机制）
//浏览器是多线程  页面渲染是单线程（js是单线程）
//进程：一个程序（一个进程中可能包含多个线程）
//线程：程序中要做的事情（一个线程同时只能做一个事情）
//在页面加载的过程中，如果遇到：【link导入外部样式资源】浏览器会新开辟一个线程，去服务器获取对应的资源条件（不会阻碍主线程的线程）
//（style内嵌样式）
//正常从上到下解析而已（解析完再继续解析dom的结构）
//（在真实项目中，如果css样式代码不是很多（再或者是移动端的项目），我们应该使用内嵌式，以此来减少http资源的请求，提高页面渲染的速度）


//（@import导入样式）（同步）
//此时不会开辟新的线程去加载资源文件，而是让主线程去获取，这样阻碍了dom结构的继续渲染，只有等把外部样式导入进来，并且解析后，才会继续渲染结构；

//（http）
//网络请求或者http请求的最大并发数=》大部分浏览器都维持在六个左右


</script>

<script>
    //页面加载中遇到js（js中会有操作dom的代码）
 //【默认script src = “xxx”】主线程会从服务器获取到js资源，并且把js资源进行解析加载，加载完成后继续渲染dom结构
 // 现代浏览器都有完善的代码扫描机制：如果遇到script需要同步加载和渲染代码，浏览器在渲染js的时候，同时会向下继续扫描代码，如果发现有一些异步的资源代码，此时就开始加载请求了
 //【如果设置了defer或者async】都是让其变为异步获取资源（不会阻碍dom的渲染）1.defer可以遵循原有的加载顺序，获取后按照顺序去依次渲染js  2.async是无序的（谁先获取到先执行谁）
 // 因为在js中还有可能操作元素的样式，所有哪怕都是异步请求资源的情况下，js先加载回来，也要等到他之前发送的css加载并渲染完成后才会执行js代码   


 //一（DOMContentLoaded事件）：当DOM结构加载完成后就会触发
   //——=》dom树有了，并且js也执行加载了，此时触发这个事件
 //二（load事件）：当所有资源都加载完成后才会触发
  // =》包含了需要等待图片等资源也都加载完才触发     
 //三（JQ类库中：$（function（）{}））或者 $(document.ready(function(){}))
  // =>1.当DOM结构加载完才会执行函数中的代码2.原理就是应用DOMContentLoaded事件完成 3.DOMContentLoaded在低版本浏览器中不兼容，不兼容使用onreadystatechange事件代替，在这个事件中监听document.readyState值，值为complete代表DOM结构加载完成


  
  //【为啥要把link写在结构的上面，把script写在结构的下面】
  //=》link放到顶部是为了更快加载回来css
  //=》script放到底部是为了获取DOM元素或者不阻碍DOM的渲染

</script>



<script>
//DOM的重绘和回流 repair&reflow
// 重绘：元素样式的改变（但宽高，大小，位置等不变）；例如outline，visibility，color，backgroud—color等
//回流：元素的大小或者位置发生改变（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染：如添加或删除可见的DOM元素，元素的位置发生变化，元素的尺寸发生变化，内容发生变化（比如文本变化或图片被另一个不同尺寸的图片所替代）；页面一开始渲染的时候（这个无法避免）；因为回流量是根据视口的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也能引起回流
   // 注意：回流一定能触发重绘，而重绘不一定会回流


 //【避免DOM的回流】  
 //1. 放弃传统操作dom的时代，基于vue/react开始数据影响视图模式
 //2.分离读写操作（现代的浏览器都有渲染队列的机制）：offsettop~会刷新渲染队列
 //3.样式集中改变：div。style。csstext = “width：20px height：10px”
 //4.缓存布局信息 div。style。left = div。offsetleft + 1 + px改为var curleft = div。offsetleft  div。style。left = div。curleft + 1 + px改
 //5.元素批量修改：模板字符串拼接
 //6.动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）
 //7.css3硬件加速（gpu加速）
 //8.避免table布局和使用css的javascript表达式  
















</script>





















</body>
</html>